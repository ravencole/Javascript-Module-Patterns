## Object Basics in Javascript

All module patterns in Javascript really just boil down to passing around objects.

As a reminder, objects in Javascript are wrapped in curley brackets and contain a list of key value pairs seperated by commas. These key value pairs can hold expressions, functions, other objects, or any other javascript type. There are several ways of creating objects in Javascipt. The most convienient, and frequent way is using Object Literals, which is what we will be utilizing.

```javascript
var myObject = {
	number: 42,
	string: 'forty-two',
	getFortyTwo: function () {
		return 42;
	},
	someNumbersLessThanFortyTwo: [41,40,39,38,37],
	colors: {
		red: 'rgb(255,0,0)',
		green: 'rgb(0,255,0)',
		blue: 'rgb(0,0,255)'
	}
};
```

Every thing that an object contians is refferded to as a property of the object, except functions, which are reffered to as methods. All properties of an object are accessable through dot notation.

```javascript
console.log(myObject.number); // 42
console.log(myObject.string); // 'forty-two'
console.log(myObject.someNumbersLessThanFortyTwo); // [41,40,39,38,37]
console.log(myObject.colors); // {red: 'rgb(255,0,0)',green: 'rgb(0,255,0)',blue: 'rgb(0,0,255)'}
```

The same syntax is used to revieve nested property

```javascript
console.log(myObject.colors.red); // 'rgb(255,0,0)'
```

Accessing items within an array is the same syntax as accessing items anywhere else within your code once you have reached the key that holds the array.

```javascript
console.log(myObject.someNumbersLessThanFortyTwo[3]); // 38
```

Methods held within an object also use the same syntax as anywhere else you might call a function. Navigate to the location of the function within the object, and call it by name with parens.

```javascript
console.log(myObject.getFortyTwo()); // 42
```

An incredibly useful thing about objects in javascript is that properties and methods can be accessed using computed values. Also, notice we will be using a method that is provided with every single object instance called hasOwnProperty(). This method returns a Boolean, true if the requested method or property exists within the object, false if not. 

```javascript
var colors = {
	red: 'rgb(255,0,0)',
	green: 'rgb(0,255,0)',
	blue: 'rgb(0,0,255)'
}

function getColor(color) {
	if (colors.hasOwnProperty(color)) {
		return colors[color];
	}
}

console.log(getColor('red')); // 'rgb(255,0,0)'
```

Objects can also be extended and modified after creation using dot notation or computed notation.

```javascript
var colors = {
	red: 'rgb(255,0,0)',
	green: 'rgb(0,255,0)',
	blue: 'rgb(0,0,255)'
}

colors['black'] = 'rgb(0,0,0)';
colors.white = 'rgb(255,255,255)';
colors.red = 'rgb(200,0,0)';
```

Lastly, object keys can be deleted using the delete keyword.

```javascript
var colors = {
	red: 'rgb(255,0,0)',
	green: 'rgb(0,255,0)',
	blue: 'rgb(0,0,255)'
}

console.log(colors.red) // 'rgb(255,0,0)'

delete colors.red;

console.log(colors.red) // undefined
```

### Objects in es2015

es2015 has given objects some syntastic conviencies. Only a few of them are perninant for this part of the writiing, but we'll get to all of them in chapters. The most useful to us right are the way methods and properties can be declared. 

In es2015, methods can be declared without explicatily assigning a key. The method is writted directly within the object and is called by the method name. The following declarations are equilivent...

```javascript
var myMethod1 = {
	returnNumber: function(num) {
		return num;
	}
}
var myMethod2 = {
	returnNumber(num) {
		return num;
	}
}
console.log(myMethod1.returnNumber(11)) // 11
console.log(myMethod2.returnNumber(11)) // 11
```

In addition to shorter method declarations when the methods are being written directly within the object, property and method declarations can also omit the key if:

1. The value of the key is an expression or function that has previously been declared
2. The key and its value have the same name

```javascript
var myNumber = 17;

function myFunction() {
	console.log('***$$***');
}

var myCollection = {
	myNumber,
	myFunction
}

console.log(myCollection.myNumber) // 17
myCollection.myFunction() // '***$$***'
```

To wrap all of this up, lets look at something useful.

Lets say that we need a config file for or application. Keeping all of our configuration within an object is a smart way to decrease code repition, seperate concerns, and make changing our configuration absolutily simple.

```javascript
var config = {
	getConfig() {
		var applicationSettings = {
			dev: {
				database: {
					host: 'mongodb://localhost/myapp',
					port: 27017
				},
				server: {
					host: 'http://localhost',
					port: 8080
				}
			},
			production: {
				database: {
					host: 'mongodb://localhost/myapp',
					port: 27017
				},
				server: {
					host: '127.0.0.1',
					port: 3000
				}
			}
		}
		var env = process.env.NODE_ENV || 'dev';
		return applicationSettings[env];
	}
};

var settings = config.get();

console.log('The application can be viewed in the browser at ' + settings.server.host + ':' + settings.server.port + ' ...!!!');
// 'The application can be viewed in the browser at http://localhost:8080 ...!!!'
```

